workflow:
  rules:
    # Run for merge requests
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

    # Run for any pushes
    - if: $CI_COMMIT_BRANCH

    # Run for tags matching vX.Y.Z pattern
    - if: $CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/

    # Don't run for branches with open merge requests
    - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
      when: never

stages:
    - init
    - quality
    - sonarqube
    - package
    - release
    - doc


# Default configuration for all jobs
# Set Usine_Logicielle_Docker a cause d'un pb proxy
default:
        tags:
            - Usine_Logicielle_Docker 
            #- Usine_Logicielle
        timeout: 30 minutes 

variables: 

    # Variables globales déclarées en dehors du yaml, définies automatiquement par Gitlab (Liste non exhaustive. Voir https://docs.gitlab.com/ee/ci/pipelines/index.html#prefill-variables-in-manual-pipelines) 
    #============================
    # CI_PIPELINE_SOURCE 
    # CI_COMMIT_BRANCH 
    # CI_OPEN_MERGE_REQUESTS 
    # CI_MERGE_REQUEST_IID
    # CI_MERGE_REQUEST_SOURCE_BRANCH_NAME
    # CI_MERGE_REQUEST_TARGET_BRANCH_NAME
    # CI_PROJECT_PATH
    # CI_COMMIT_REF_SLUG
    # CI_PIPELINE_ID
    # CI_PIPELINE_URL
    # CI
    # … 
    
    # Variables globales déclarées en dehors du yaml, définies par l'UL au niveau de l’instance Gitlab 
    #============================
    # CNES_CERTIFICATE 
    
    # Variables globales déclarées en dehors du yaml, définies par l'UL, au niveau du groupe Gitlab dans le menu "Settings > CI/CD > Variables", et héritées par le projet : 
    #============================
    # Pour les images Docker sur Artifactory : 
    # DOCKER_AUTH_CONFIG 
    # Pour la connexion à Artifactory : 
    # ARTIFACTORY_HOST 
    # ARTIFACTORY_USER 
    # ARTIFACTORY_TOKEN 
    # Pour la connexion à SonarQube : 
    # GRIDR_SONAR_TOKEN 
    # SONARQUBE_HOST 
    
    # Variables globales déclarées dans le yaml, constituant des "paramètres" pour les jobs manuels :
    #============================
    DEBUG:
        value: 'false'
        description: "Afficher des logs supplémentaires"

    # Variables globales déclarées dans le yaml 
    
    # Tags des images exclusives python
    TAG_UL_IMAGE_PYTHON_DEFAULT_VERSION: "3.11"
    TAG_UL_IMAGE_PYTHON: "python:${TAG_UL_IMAGE_PYTHON_DEFAULT_VERSION}"

    # Definition des variables pour la definition de l'image a utiliser pour la creation du venv, build et test.
    # L'image est definie par : "rust_python:rust-${TAG_IMAGE_RUST_VERSION}_python-${TAG_IMAGE_PYTHON_VERSION}_${TAG_IMAGE_OS}"
    TAG_IMAGE_RUST_VERSION: "1.89"
    TAG_IMAGE_PYTHON_VERSION_311: "3.11.12"
    TAG_IMAGE_PYTHON_VERSION_310: "3.10.17"
    #TAG_IMAGE_OS: "bookworm-slim"
    TAG_IMAGE_OS: "rockylinux8-minimal"
    
    TAG_IMAGE_PYTHON_DEFAULT_VERSION: "3.11.12"
    TAG_IMAGE_RUST_DEFAULT_VERSION: "1.89"
    # Set the numpy version (temp)
    NUMPY_VERSION_MIN: "1.25.0"

    TAG_IMAGE_SONAR: "sonarsource/sonar-scanner-cli:4.5"
    #============================
    # Variables pour les tags des images Docker à utiliser pour les jobs 
    #---------------------------  
    
    # Variables pour le client Command Line Interface "JFrog CLI" (voir https://www.jfrog.com/confluence/display/CLI/JFrog+CLI)
    #---------------------------
    # CI : [Default: false] If true, disables interactive prompts and progress bar.
    CI: "true"
    # Variables pour les applications JFrog, Artifactory, les artefacts, etc 
    #---------------------------
    # url générique du serveur contenant les images docker
    ARTIFACTORY_URL: "${ARTIFACTORY_HOST}/docker"
    # url permettant d'adresser les images rust python mise en places specifiquement pour gridr
    ARTIFACTORY_RUST_PYTHON_IMAGE_URL: "${ARTIFACTORY_HOST}/gridr-docker-local"
    
    # url générique du serveur contenant les images docker gitlab
    ARTIFACTORY_GITLAB_URL: "${ARTIFACTORY_HOST}/gitlab-docker-remote"


    # URL pour récupérer l'image Docker pour exécuter l'analyse décrite dans le template SAST
    CI_TEMPLATE_REGISTRY_HOST: "${ARTIFACTORY_HOST}/gitlab-docker-remote"

    # Variables pour le développement de l'application 
    #---------------------------
    # Necessaire pour le virtual env pour ne pas partir en timeout car internet n'est pas configure
    PIP_INDEX_URL : "https://${ARTIFACTORY_USER}:${ARTIFACTORY_TOKEN}@${ARTIFACTORY_HOST}/artifactory/api/pypi/pypi/simple"
    PIP_CERT: "${CNES_CERTIFICATE}"
    # Variable pour deplacer le dossier de cache de pip dans le workspace
    PIP_CACHE_DIR: "${WORKSPACE}/.pip-cache/"
    # Declaration des arguments de la ligne de commande de PIP
    PIP_ARG_MAIN: "--cert ${PIP_CERT} --index-url ${PIP_INDEX_URL} "


    # Variable proxy necessaires pour cargo - comment all due to CNES new transparent http proxy
    #HTTP_PROXY: http://${PROXY_USER}:${PROXY_PWD}@${PROXY_SERVER}
    #HTTPS_PROXY: http://${PROXY_USER}:${PROXY_PWD}@${PROXY_SERVER}
    #NO_PROXY: ${NO_PROXY}
    #http_proxy: http://${PROXY_USER}:${PROXY_PWD}@${PROXY_SERVER}
    #https_proxy: http://${PROXY_USER}:${PROXY_PWD}@${PROXY_SERVER}
    #no_proxy: ${NO_PROXY}

    #ASDF_RELEASE_DOWNLOAD_URL: https://github.com/asdf-vm/asdf/releases/download/v0.16.1/asdf-v0.16.1-linux-amd64.tar.gz
    #ASDF_INSTALL_PATH: "${WORKSPACE}/asdf"

    # Index PIP additionnels
    #PIP_INDEX_ARTEMIS_URL: "https://${ARTIFACTORY_USER}:${ARTIFACTORY_TOKEN}@${ARTIFACTORY_HOST}/artifactory/api/pypi/${ARTIFACTORY_ARTEMIS_PIP}/simple"
    #PIP_INDEX_ARTEMIS_CONTRIB_URL: "https://${ARTIFACTORY_USER}:${ARTIFACTORY_TOKEN}@${ARTIFACTORY_HOST}/artifactory/api/pypi/${ARTIFACTORY_ARTEMIS_CONTRIB_PIP}/simple"
    # Construction des arguments pour PIP



rust_python_init:
    stage: init
    parallel:
        matrix:
          #- TAG_IMAGE_PYTHON_VERSION: "3.10.17"
          - TAG_IMAGE_PYTHON_VERSION: "3.11.12"
          - TAG_IMAGE_PYTHON_VERSION: "3.10.17"
            NUMPY_VERSION: "1.25.0"
    # Utilisation de l'image rust_python generee specifiquement
    image: ${ARTIFACTORY_RUST_PYTHON_IMAGE_URL}/rust_python:rust-${TAG_IMAGE_RUST_VERSION}_python-${TAG_IMAGE_PYTHON_VERSION}_${TAG_IMAGE_OS}
    variables:
        SSL_CERT_FILE: '${CNES_CERTIFICATE}' 
        GIT_SSL_CAINFO: '${CNES_CERTIFICATE}'
    before_script:
        # Définition d'un UUID unique 
        - export UUID=$(cat /proc/sys/kernel/random/uuid)
        # Export de UUID pour le faire passer entre les jobs
        - echo ${UUID} > uuid.txt
    script:
        # Mise en place du venv
        #- VENV_VERSION_PYTHON=python_env_${TAG_IMAGE_PYTHON_VERSION}_numpy${NUMPY_VERSION}
        #- GRIDR_VENV=${VENV_VERSION_PYTHON} NUMPY_VERSION=${NUMPY_VERSION} make venv
        - |
            if [ -z "${NUMPY_VERSION:-}" ]; then
                echo "NUMPY_VERSION not set, using default venv"
                VENV_VERSION_PYTHON=python_env_${TAG_IMAGE_PYTHON_VERSION}
                GRIDR_VENV=${VENV_VERSION_PYTHON} make venv
            else
                echo "NUMPY_VERSION is set to ${NUMPY_VERSION}, using numpy-specific venv"
                VENV_VERSION_PYTHON=python_env_${TAG_IMAGE_PYTHON_VERSION}_numpy${NUMPY_VERSION}
                GRIDR_VENV=${VENV_VERSION_PYTHON} NUMPY_VERSION=${NUMPY_VERSION} make venv
            fi

    timeout: 15 minutes
    artifacts:
        untracked: true
        expire_in: 1 day

python_init:
    stage: init
    image: ${ARTIFACTORY_URL}/python:${TAG_UL_IMAGE_PYTHON_DEFAULT_VERSION}
    rules:
        # Run for tags matching vX.Y.Z pattern
        - if: $CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/

        # Do not run this job otherwise
        - when: never
        #  when: never                                  # Do not run this job when a tag is created manually
        #- if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH  # Run this job when commits are pushed or merged to the default branch
    
    script:
        # Mise en place du venv
        - TAG_VERSION_PYTHON="3_11"
        - VENV_VERSION_PYTHON=python_only_env_${TAG_VERSION_PYTHON}
        - python -m venv ${VENV_VERSION_PYTHON}
        - source ${VENV_VERSION_PYTHON}/bin/activate
        # Mise a jour pip
        - pip install --upgrade pip ${PIP_ARG_MAIN} --no-cache-dir
        - pip install -r requirements_dev.txt ${PIP_ARG_MAIN} --no-cache-dir
        - pip install twine ${PIP_ARG_MAIN} --no-cache-dir
        - deactivate
    timeout: 15 minutes
    artifacts:
        untracked: true
        expire_in: 1 day
        
        
pytest:
    stage: quality
    # Utilisation de l'image rust 1.79 bookworm ( bookworm base sur une Debian 12 (bullseye pour Debian 11))
    # Debian 12 : python 3.11
    # Debian 11 : python 3.9
    #image: ${ARTIFACTORY_URL}/rust:1.79.0-bookworm
    parallel:
        matrix:
          #- TAG_IMAGE_PYTHON_VERSION: "3.10.17"
          - TAG_IMAGE_PYTHON_VERSION: "3.11.12"
          - TAG_IMAGE_PYTHON_VERSION: "3.10.17"
            NUMPY_VERSION: "1.25.0"
    image: ${ARTIFACTORY_RUST_PYTHON_IMAGE_URL}/rust_python:rust-${TAG_IMAGE_RUST_VERSION}_python-${TAG_IMAGE_PYTHON_VERSION}_${TAG_IMAGE_OS}
    needs: 
        - rust_python_init
    variables:
        SSL_CERT_FILE: '${CNES_CERTIFICATE}' 
        GIT_SSL_CAINFO: '${CNES_CERTIFICATE}'
    before_script:
        # Ajout des certificats CNES pour permettre au runner de cloner le dépôt Gitlab.
        #- cat ${CNES_CERTIFICATE} > /usr/local/share/ca-certificates/my-cert.crt
        # Mise à jour des certificats
        #- update-ca-certificates
        - echo "before"
    script:
        # Mise en place du venv
        #- VENV_VERSION_PYTHON=python_env_${TAG_IMAGE_PYTHON_VERSION}_numpy${NUMPY_VERSION}
        #- GRIDR_VENV=${VENV_VERSION_PYTHON} NUMPY_VERSION=${NUMPY_VERSION} make test-python
        - |
            if [ -z "${NUMPY_VERSION:-}" ]; then
                echo "NUMPY_VERSION not set, using default venv"
                VENV_VERSION_PYTHON=python_env_${TAG_IMAGE_PYTHON_VERSION}
                GRIDR_VENV=${VENV_VERSION_PYTHON} COVERAGE_REPORT_TAG="_${CI_NODE_INDEX}" make test-python
            else
                echo "NUMPY_VERSION is set to ${NUMPY_VERSION}, using numpy-specific venv"
                VENV_VERSION_PYTHON=python_env_${TAG_IMAGE_PYTHON_VERSION}_numpy${NUMPY_VERSION}
                GRIDR_VENV=${VENV_VERSION_PYTHON} COVERAGE_REPORT_TAG="_${CI_NODE_INDEX}" NUMPY_VERSION=${NUMPY_VERSION} make test-python
            fi
        - |
            if [ "$TAG_IMAGE_PYTHON_VERSION" = "$PYTEST_COVERAGE_PYTHON_VERSION" ]; then
              mv report_${CI_NODE_INDEX}.xml report.xml
              mv .coverage-reports/coverage_${CI_NODE_INDEX}.xml .coverage-reports/coverage.xml
            else
              rm -f report_${CI_NODE_INDEX}.xml
              rm -f .coverage-reports/coverage_${CI_NODE_INDEX}.xml
            fi
    artifacts:
        untracked: true
        expire_in: 1 day
        reports:
            junit: report.xml
    cache:
        key: "coverage-python-reports"
        paths:
          - .coverage-reports/coverage.xml
        policy: push


pylint_analysis:
    stage: quality
    # Utilisation de l'image rust 1.79 bookworm ( bookworm base sur une Debian 12 (bullseye pour Debian 11))
    # Debian 12 : python 3.11
    # Debian 11 : python 3.9
    parallel:
        matrix:
          #- TAG_IMAGE_PYTHON_VERSION: "3.10.17"
          - TAG_IMAGE_PYTHON_VERSION: "3.11.12"
          #- TAG_IMAGE_PYTHON_VERSION: "3.10.17"
          #  NUMPY_VERSION: "1.25.0"
    image: ${ARTIFACTORY_RUST_PYTHON_IMAGE_URL}/rust_python:rust-${TAG_IMAGE_RUST_VERSION}_python-${TAG_IMAGE_PYTHON_VERSION}_${TAG_IMAGE_OS}
    needs: 
        - rust_python_init
    script:
        # For now manual set TAG_VERSION_PYTHON
        #- TAG_VERSION_PYTHON="3_11"
        # Mise en place du venv
        - VENV_VERSION_PYTHON=python_env_${TAG_IMAGE_PYTHON_VERSION}_numpy${NUMPY_VERSION}
        - GRIDR_VENV=${VENV_VERSION_PYTHON} make pylint
    artifacts:
        # Optimiser l'archivage au strict minimum pour gagner de l'espace et du transferts de bande passante
        paths:
          - ./pylint_report.json
        expire_in: 1 day

sonarqube:
    stage: sonarqube
    image: ${ARTIFACTORY_URL}/${TAG_IMAGE_SONAR}
    needs:
      - pytest
      - pylint_analysis
    variables:
        # Definition de variables pour configuer sonar scanner
        # Ces variables sont appelées par defaut par sonar-scanner
        SONAR_TOKEN: ${SONARQUBE_TOKEN}
        SONAR_HOST_URL: https://${SONARQUBE_HOST}
        GIT_DEPTH: 0  #Prevent clone shallow error
    before_script:
        # Ajout un seul certificat du CNES dans java pour accéder à SonarQube en HTTPS. C'est lié à une limitation de Keytool.
        # Nous sommes obligé de prendre un autre certificat car sonar-scanner ne se base pas sur l'intégralité de la chaine de certificat mais seulement du premier parent du serveur.
        - keytool -importcert -alias sonarqube -file "/certs-cnes/AC_TECHNIQUE_SERVEURS_2028.crt" -keystore ${JAVA_HOME}/lib/security/cacerts -storepass changeit -noprompt
 
    script:
        - |-
            if [ ${CI_PIPELINE_SOURCE} == "merge_request_event" ]; then
              SONARQUBE_PARAMETERS="-Dsonar.pullrequest.key='${CI_MERGE_REQUEST_IID}' -Dsonar.pullrequest.branch='${CI_MERGE_REQUEST_SOURCE_BRANCH_NAME}' -Dsonar.pullrequest.base='${CI_MERGE_REQUEST_TARGET_BRANCH_NAME}'"
            elif [[ ${CI_COMMIT_BRANCH} =~ ^(feature|hotfix|bugfix|release|develop).*$ ]]; then
              SONARQUBE_PARAMETERS="-Dsonar.branch.name='${CI_COMMIT_BRANCH}'"
            fi
        - "[ $DEBUG = true ] && echo sonar-scanner ${SONARQUBE_PARAMETERS} -Dsonar.externalIssuesReportPaths=pylint_report.json -Dsonar.sources=python -Dsonar.python.coverage.reportPaths=.coverage-reports/* -Dsonar.qualitygate.wait=true -Dsonar.qualitygate.timeout=300"
        # Scan du projet avec sonar-scanner
        - |-
            if [[ -z ${SONAR_PROJECT_KEY} ]]; then 
                sonar-scanner ${SONARQUBE_PARAMETERS} -X -Dsonar.verbose=true -Dsonar.externalIssuesReportPaths=pylint_report.json -Dsonar.sources=python -Dsonar.python.coverage.reportPaths=.coverage-reports/* -Dsonar.qualitygate.wait=true -Dsonar.qualitygate.timeout=300
            else 
                sonar-scanner ${SONARQUBE_PARAMETERS} -X -Dsonar.verbose=true -Dsonar.externalIssuesReportPaths=pylint_report.json -Dsonar.sources=python -Dsonar.python.coverage.reportPaths=.coverage-reports/* -Dsonar.projectKey="${SONAR_PROJECT_KEY}" -Dsonar.projectName="${SONAR_PROJECT_NAME}" -Dsonar.qualitygate.wait=true -Dsonar.qualitygate.timeout=300
            fi
      
    allow_failure: true
    artifacts:
        untracked: true
        expire_in: 1 day
    cache:
        key: "coverage-python-reports"
        paths:
          - .coverage-reports/coverage.xml
        policy: pull

package-build:
    stage: package
    # Utilisation de l'image rust 1.79 bookworm ( bookworm base sur une Debian 12 (bullseye pour Debian 11))
    # Debian 12 : python 3.11
    # Debian 11 : python 3.9
    parallel:
        matrix:
          - TAG_IMAGE_PYTHON_VERSION: "3.11.12"
          - TAG_IMAGE_PYTHON_VERSION: "3.10.17"
            NUMPY_VERSION: "1.25.0"
    image: ${ARTIFACTORY_RUST_PYTHON_IMAGE_URL}/rust_python:rust-${TAG_IMAGE_RUST_VERSION}_python-${TAG_IMAGE_PYTHON_VERSION}_${TAG_IMAGE_OS}
    needs: 
        - rust_python_init
    variables:
        SSL_CERT_FILE: '${CNES_CERTIFICATE}' 
        GIT_SSL_CAINFO: '${CNES_CERTIFICATE}'
    before_script:
        # Ajout des certificats CNES pour permettre au runner de cloner le dépôt Gitlab.
        #- cat ${CNES_CERTIFICATE} > /usr/local/share/ca-certificates/my-cert.crt
        # Mise à jour des certificats
        #- update-ca-certificates
        #- cat ${CNES_CERTIFICATE} > ${WORKSPACE}/my-cert.crt
        #- export SSL_CERT_FILE="${WORKSPACE}/my-cert.crt"  # Pour Python, curl, etc.
        #- export GIT_SSL_CAINFO="${WORKSPACE}/my-cert.crt" # Pour git clone
        # Installation dependances de build
        #- apt-get update && apt-get install -y build-essential procps curl file git
        #FOR NOW THE CI ONLY WORKS WITH DEBIAN 12 PACKAGED PYTHON      
        #- apt-get update && apt-get install -y python3.11 libpython3.11-dev python3.11-venv python3-pip
        - echo "before"
    script:
        # For now manual set TAG_VERSION_PYTHON
        #- TAG_VERSION_PYTHON="3_11"
        # Mise en place du venv
        #- VENV_VERSION_PYTHON=python_env_${TAG_IMAGE_PYTHON_VERSION}_numpy${NUMPY_VERSION}
        #- GRIDR_VENV=${VENV_VERSION_PYTHON} NUMPY_VERSION=${NUMPY_VERSION} make build
        - |
            if [ -z "${NUMPY_VERSION:-}" ]; then
                echo "NUMPY_VERSION not set, using default venv"
                VENV_VERSION_PYTHON=python_env_${TAG_IMAGE_PYTHON_VERSION}
                GRIDR_VENV=${VENV_VERSION_PYTHON} BUILD_DIST_OUTDIR=dist_${CI_NODE_INDEX} make build
            else
                echo "NUMPY_VERSION is set to ${NUMPY_VERSION}, using numpy-specific venv"
                VENV_VERSION_PYTHON=python_env_${TAG_IMAGE_PYTHON_VERSION}_numpy${NUMPY_VERSION}
                GRIDR_VENV=${VENV_VERSION_PYTHON} BUILD_DIST_OUTDIR=dist_${CI_NODE_INDEX} NUMPY_VERSION=${NUMPY_VERSION} make build
            fi
        - mkdir -p dist && mv dist_${CI_NODE_INDEX}_fixed/* dist/
    artifacts:
        untracked: true
        expire_in: 1 day



# Stage : release
# Deploy previously generated packages to artifactory
.template_release_job:
    image: ${ARTIFACTORY_URL}/python:${TAG_UL_IMAGE_PYTHON_DEFAULT_VERSION}
    stage: release
    rules:
        #- if: $CI_COMMIT_TAG
        #  when: never                                  # Do not run this job when a tag is created manually
        #- if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH  # Run this job when commits are pushed or merged to the default branch
        - if: $CI_COMMIT_TAG =~ /^v\d+\.\d+\.\d+$/
        - when: never
#
release-publish-artifactory:
    extends: .template_release_job
    needs:
        - python_init
        - package-build
        - pytest
    script:
        # Mise en place du venv
        #- TAG_VERSION_PYTHON="3_11"
        #- VENV_VERSION_PYTHON=python_only_env_${TAG_VERSION_PYTHON}
        #- source ${VENV_VERSION_PYTHON}/bin/activate
        #- ls dist/*
        #- python -m twine upload --verbose --cert ${CNES_CERTIFICATE} --repository-url https://${ARTIFACTORY_HOST}/artifactory/api/pypi/${ARTIFACTORY_GRIDR_PIP} --username ${ARTIFACTORY_USER} --password ${ARTIFACTORY_TOKEN} dist/*
        #- !reference [.template_release_job, script]
        - |
          TAG_VERSION_PYTHON="3_11"
          # Extraire la version du tag
          TAG_VERSION=${CI_COMMIT_TAG#v}
          # Extraire la version de pyproject.toml
          PYPROJECT_VERSION=$(grep -E -o "version(\s){0,}=(\s){0,}\"[0-9]+?\.[0-9]+?(\.[0-9]+?)?\"" pyproject.toml | grep -E -o "[0-9]+?\.[0-9]+?(\.[0-9]+?)?")
          # Vérifier si les versions correspondent
          if [ "$TAG_VERSION" == "$PYPROJECT_VERSION" ]; then
            echo "Versions match: $TAG_VERSION"
            # Publier l'artefact (exemple avec twine)
            VENV_VERSION_PYTHON=python_only_env_${TAG_VERSION_PYTHON}
            source ${VENV_VERSION_PYTHON}/bin/activate
            python -m twine upload --verbose --cert ${CNES_CERTIFICATE} --repository-url https://${ARTIFACTORY_HOST}/artifactory/api/pypi/${ARTIFACTORY_GRIDR_PIP} --username ${ARTIFACTORY_USER} --password ${ARTIFACTORY_TOKEN} dist/*
          else
            echo "Version mismatch: Tag=$TAG_VERSION, pyproject.toml=$PYPROJECT_VERSION"
            exit 1
          fi

    timeout: 15 minutes
    artifacts:
        untracked: true
        expire_in: 1 day

# Stage : Release
# Ajout de variables d'environnement a recuperer dans le job gitlab_release_job
# Ce job recupere la version a partir du pyproject. Cette version servira de tag
# pour le job qui suit
# A ne faire que si la branche de commit est le main et si pas de tag manuel
gitlab_release_init_job:
   extends: .template_release_job
   needs:
       - release-publish-artifactory
   script:
       # Recuperation de la version a partir du pyproject
       - PYPROJECT_VERSION=$(grep -E -o "version(\s){0,}=(\s){0,}\"[0-9]+?\.[0-9]+?(\.[0-9]+?)?\"" pyproject.toml | grep -E -o "[0-9]+?\.[0-9]+?(\.[0-9]+?)?")
       - echo "EXTRA_DESCRIPTION=${PYPROJECT_VERSION}" >> variables.env  # Generate the EXTRA_DESCRIPTION and TAG environment variables
       - echo "TAG=${PYPROJECT_VERSION}" >> variables.env             # and append to the variables.env file
       #- !reference [.template_release_job, script]
   artifacts:
       reports:
           dotenv: variables.env                                   # Use artifacts:reports:dotenv to expose the variables to other jobs
   timeout: 15 minutes

# Stage : Release
# Creation automatique du tag en recuperant le numero de version du projet python
# A ne faire que si la branche de commit est le main et si pas de tag manuel
gitlab_release_job:
   extends: .template_release_job
   image: ${ARTIFACTORY_GITLAB_URL}/gitlab-org/release-cli:latest
   variables:
       SSL_CERT_FILE: '${CNES_CERTIFICATE}' # assuming the cert exists in your repo or it has been downloaded before
       #SSL_CERT_DIR: '${CNES_CERTIFICATE}'  # use this variable if you want to use more than one custom certificates
   needs:
       - release-publish-artifactory
       - gitlab_release_init_job
   script:
       - echo "Running release for TAG ${TAG}"
   release:
       name: 'Release ${TAG}'
       tag_name: '${TAG}'
       description: 'Release using the release-cli ; v${EXTRA_DESCRIPTION}'
       ref: '$CI_COMMIT_SHA'

   timeout: 15 minutes
   artifacts:
       untracked: true
       expire_in: 1 day

        
build_doc:
    # Utilisation de l'image rust 1.79 bookworm ( bookworm base sur une Debian 12 (bullseye pour Debian 11))
    # Debian 12 : python 3.11
    # Debian 11 : python 3.9
    #image: ${ARTIFACTORY_URL}/rust:1.79.0-bookworm
    image: ${ARTIFACTORY_RUST_PYTHON_IMAGE_URL}/rust_python:rust-${TAG_IMAGE_RUST_DEFAULT_VERSION}_python-${TAG_IMAGE_PYTHON_DEFAULT_VERSION}_${TAG_IMAGE_OS}
    stage: doc
    rules:
        - if: $CI_COMMIT_TAG
          when: never                                  # Do not run this job when a tag is created manually
        - if: '$CI_COMMIT_BRANCH == "$CI_DEFAULT_BRANCH" || $CI_COMMIT_BRANCH == "main"'
    needs: 
        - rust_python_init
    variables:
        SSL_CERT_FILE: '${CNES_CERTIFICATE}'
    #before_script:
        # Ajout des certificats CNES pour permettre au runner de cloner le dépôt Gitlab.
        #- cat ${CNES_CERTIFICATE} > /usr/local/share/ca-certificates/my-cert.crt
        # Mise à jour des certificats
        #- update-ca-certificates
        # Installation dependances de build
        #- apt-get update && apt-get install -y build-essential procps curl file git
        #FOR NOW THE CI ONLY WORKS WITH DEBIAN 12 PACKAGED PYTHON      
        #- apt-get update && apt-get install -y python3.11 libpython3.11-dev python3.11-venv python3-pip
    script:
        # For now manual set TAG_VERSION_PYTHON
        #- TAG_VERSION_PYTHON="3_11"
        # Mise en place du venv
        - VENV_VERSION_PYTHON=python_env_${TAG_IMAGE_PYTHON_DEFAULT_VERSION}
        - GRIDR_VENV=${VENV_VERSION_PYTHON} make build-sphinx-doc
    artifacts:
        untracked: true
        expire_in: 1 day

pages:
    image: ${ARTIFACTORY_URL}/python:${TAG_UL_IMAGE_PYTHON_DEFAULT_VERSION}
    stage: doc
    rules:
        - if: $CI_COMMIT_TAG
          when: never                                  # Do not run this job when a tag is created manually
        - if: $CI_COMMIT_BRANCH == "main"  # Run this job when commits are pushed or merged to the default branch
        #- if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH  # Run this job when commits are pushed or merged to the default branch
    needs:
        - build_doc
    script:
        # Mise en place du venv
        - cp -r docs/build/html public
    artifacts:
        paths:
        - public
