# coding: utf8
#
# Copyright (c) 2024 Centre National d'Etudes Spatiales (CNES).
#
# This file is part of GRIDR
# (see https://gitlab.cnes.fr/gridr/gridr).
#
#
"""
Grid utils module
"""
from typing import Tuple, Union, Optional

import numpy as np
from rasterio.features import rasterize
from rasterio.transform import Affine
import shapely
from scipy.interpolate import RegularGridInterpolator

from gridr.core.utils.array_window import (window_check, window_apply,
        window_shape, window_expand_ndim)
from gridr.core.utils.array_utils import ArrayProfile


def interpolate_grid(
        grid: Optional[np.ndarray],
        grid_mask: Optional[np.ndarray],
        x: np.ndarray,
        y: np.ndarray,
        x_new: np.ndarray,
        y_new: np.ndarray,
        dtype: Optional[np.dtype] = None,
        mask_binarize_precision: float = 1e-6,
        mask_dtype: np.dtype = np.uint8,
        ) -> Tuple[np.ndarray]:
    """Interpolate a 3-dimensionnal grid and its associated 2-dimensional mask.
    The first dimension of the grid contain the variable.
    
    We assume here that the mask respect the convention where all non zero
    values are considered masked. The output mask will be binarized (i.e values
    equal to 0 or 1) according a binarization threshold used on the interpolated
    values :
    
        final_mask(i,j) = 0 only if abs(interp_mask(i-j)) < threshold
    
    The grid is interpolated on the mesh generated by the x_new and y_new
    coordinates and using a linear interpolation.
    
    Args:
        grid: input 3-dimensionnal grid
        grid_mask : input 2-dimensionnal mask
        x : 1D coordinates associated to the grid (and mask) for column's
            indexes.
        y : 1D coordinates associated to the grid (and mask) for row's indexes.
        x_new: 1D coordinates associated to the interpolated grid and mask for
            columns.
        y_new: 1D coordinates associated to the interpolated grid and mask for
            rows.
        dtype: dtype to use for computation. If None it uses the same dtype as
            input grid
        mask_binarize_precision: threshold used for interpolated mask
            binarization.
        mask_dtype: type of the output mask (should be np.uint8 or bool)
    """
    interp_grid = None
    interp_grid_mask = None
    
    # Create the "sparse" coordinates grid in order to preserve memory
    x_new_sparse, y_new_sparse = np.meshgrid(x_new, y_new, indexing='xy',
            sparse=True)
    
    if dtype is None:
        dtype=grid.dtype
    
    # Init the output grid
    if grid is not None:
        n_vars = grid.shape[0]
        interp_grid = np.empty((grid.shape[0], len(y_new), len(x_new)),
                dtype=dtype)
        
        # Loop on each variable to perform interpolation
        for i in range(n_vars):
            # Create the interpolator
            interpolator = RegularGridInterpolator((y, x), grid[i, :, : ],
                    method='linear', bounds_error=False, fill_value=np.nan)
            # Perform the interpolation
            interp_grid[i, :, :] = interpolator((y_new_sparse, x_new_sparse))
        
    # Perform interpolation on mask
    if grid_mask is not None:
        # Init the mask
        interp_grid_mask = np.empty(grid_mask.shape)
        
        interpolator = RegularGridInterpolator((y, x), grid_mask[:, : ],
                method='linear', bounds_error=False, fill_value=np.nan)
        # Perform the interpolation
        interp_grid_mask = interpolator((y_new_sparse, x_new_sparse))
        # The interpolator will generate interpolated values
        # If we are strict we will only consider unmasked data to have
        # strictly the mask_value (almost equal with a precision)
        interp_grid_mask = (np.abs(interp_grid_mask) >= mask_binarize_precision
                ).astype(mask_dtype)
    
    return interp_grid, interp_grid_mask


def oversample_regular_grid(
        grid: Optional[np.ndarray],
        grid_oversampling_row: int,
        grid_oversampling_col: int,
        grid_mask: Optional[np.ndarray],
        dtype: Optional[np.dtype] = None,
        grid_mask_binarize_precision: Optional[float] = 1e-6,
        grid_mask_dtype: np.dtype = np.uint8,
        win: Optional[np.ndarray] = None,
        ) -> Tuple[Optional[np.ndarray], Optional[np.ndarray]]:
    """ Get an linear interpolated oversampled grid from the input grid.
    """
    # Check that the grid dimension is 3
    out_grid, out_grid_mask = None, None
    nrows, ncols = None, None
    
    if grid is not None:
        assert(grid.ndim == 3)
        nrows, ncols = grid.shape[1:]
    else:
        nrows, ncols = grid_mask.shape
        
    # Define the window to the full data if not given
    if win is None:
        # Define the window on full grid
        # - first idx is 0
        # - last idx equals to (shape(axis) - 1) * oversampling
        # => the number of points along an axis is given by :
        #    (shape(axis) -1) * oversampling + 1
        win = np.asarray([[0, (nrows-1)*grid_oversampling_row],
                [0, (ncols-1)*grid_oversampling_col]])
    
    # Check the window is OK - for that we pass an ArrayProfile in order to
    # mock the output array's profile
    out_array_profile = ArrayProfile(shape=((nrows-1)*grid_oversampling_row+1,
            (ncols-1)*grid_oversampling_col+1), ndim=2, dtype=float)

    if not window_check(out_array_profile, win):
        raise Exception('window outside of output grid domain')
    
    # Check dtype to use
    if dtype is None:
        if grid is not None and np.issubdtype(grid.dtype, np.floating):
            dtype = grid.dtype
        else:
            raise ValueError("You must precise argument 'dtype'. Cannot tell "
                    "if float32 or float64 should be used")
    
    # Create associated coordinates
    # Input grid coordinates
    #y = np.arange(0, nrows, dtype=xy_dtype) * grid_oversampling_row
    #x = np.arange(0, ncols, dtype=xy_dtype) * grid_oversampling_col
    # Target grid coordinates
    #y_new = np.arange(win[0,0], win[0,1]+1, dtype=xy_dtype)
    #x_new = np.arange(win[1,0], win[1,1]+1, dtype=xy_dtype)
    
    y = np.linspace(0, (nrows-1) * grid_oversampling_row, nrows, dtype=dtype)
    x = np.linspace(0, (ncols-1) * grid_oversampling_col, ncols, dtype=dtype)

    y_new = np.linspace(win[0,0], win[0,1], win[0,1] - win[0,0] + 1, dtype=dtype)
    x_new = np.linspace(win[1,0], win[1,1], win[1,1] - win[1,0] + 1, dtype=dtype)
    
    # Interpolate the grid
    out_grid, out_grid_mask = interpolate_grid(grid=grid, 
                grid_mask=grid_mask, x=x, y=y, x_new=x_new, y_new=y_new,
                dtype=dtype,
                mask_binarize_precision=grid_mask_binarize_precision,
                mask_dtype=grid_mask_dtype,
                )
    return out_grid, out_grid_mask


def build_grid(
        resolution: Tuple[int, int],
        grid: np.ndarray,
        grid_target_win: np.ndarray,
        grid_resolution: Tuple[int, int],
        out: np.ndarray,
        computation_dtype: Optional[np.dtype] = None,
        ) -> Optional[np.ndarray]:
    """
    Create the target resolution grid.
    
    This method only works on raster and do not perform IO.
    
    A preallocated output buffer can be passed to the method through the 'out'
    arugment. If it is given it must be consistent with the given 'shape'.
    
    The dtype to use for interpolation can also be given. Please note that if it
    does not correspond to the 'out' data type (or the 'grid' data if 'out' is
    no provided), the dtype used for interpolation can be different from the 
    data dtype. An implicit cast to the output dtype will be performed at final
    output assignment.
    
    Args:
        resolution: the resolution of the output grid. Only full resolution (ie
                (1,1) is currently implemented. The resolution is used for the
                resampling (oversampling) of the input grid.
        grid: the input grid
        grid_target_win: the production window given as a list of  
                2 tuples containing the first and last index for the row and column
                dimensions, i.e : 
                (((first_row, last_row), (first_col, last_col))
                It is defined in the output grid coordinates system.
        grid_resolution: the input grid resolution in row and column.
        out: an optional preallocated buffer to store the result
        computation_dtype: an optional data type that will be used of
                interpolation. If None if will use the 'out' data type if given,
                the 'grid' data type otherwise.
        
    Returns:
        The computed grid or None if `out` is not None.
    """
    ret = None
    # -- Perform some checks on arguments and init optional arguments
    if resolution is None:
        raise ValueError("You must provide both the 'shape' and 'resolution' "
                "arguments")
    if grid is None:
        raise ValueError("You must provide the 'grid' argument")
    if grid.ndim != 3:
        raise ValueError("Input grid must have 3 dimensions")
    
    if ~np.all(resolution == (1,1)):
        raise ValueError("Output resolution different from full resolution have"
                " not been implemented yet")
    
    grid_full_res_profile = ArrayProfile(
            shape=(grid.shape[0], 
                    (grid.shape[1]-1)*grid_resolution[0]+1,
                    (grid.shape[2]-1)*grid_resolution[1]+1),
            ndim=grid.ndim, dtype=grid.dtype)
    
    if grid_target_win is None:
        # Compute full size
        grid_target_win = np.asarray([[0, grid_full_res_profile.shape[1]-1],
                [0, grid_full_res_profile.shape[2]-1]])
    else:
        grid_target_win = np.asarray(grid_target_win)
        if grid_target_win.ndim != 2:
            raise ValueError("The argument 'grid_target_win' must be a 2d "
                    "window")
    grid_target_win3 = window_expand_ndim(grid_target_win, (0, grid.shape[0]-1))     
    
    #check that the target window lies in the full resolution grid
    if not window_check(arr=grid_full_res_profile,
            win=grid_target_win3, axes=None):
        raise ValueError(
                "Target window error is not contained in input grid : "
                f"\n\t Input grid : {grid_full_res_profile.shape}"
                f"\n\t Window : {grid_target_win3}")
    
    # Compute shape
    shape3 = window_shape(grid_target_win3)
    
    # Init output buffer if not given
    if out is None:
        out = np.zeros(shape3, dtype=grid.dtype)
        ret = out
    elif ~np.all(out.shape == shape3):
        raise ValueError("The values of the 2 arguments 'out' and 'shape' does "
                "not match.")
    
    if computation_dtype is None:
        computation_dtype = out.dtype
    #elif dtype != out.dtype:
        #raise ValueError(f"Ouput data type {out.dtype} does not match with the "
        #        f"input argument 'dtype' {dtype}")
    # -- End of argument's checks
    
    if grid_resolution[0] != 1 or grid_resolution[1] != 1:
        # We have to oversample the grid to the output resolution
        # FUTURE_WARNING : if resolution_out != (1,1) we will have to
        # reimplement this part
        out[:,:,:], _ = oversample_regular_grid(
                grid = grid,
                grid_oversampling_row=grid_resolution[0],
                grid_oversampling_col=grid_resolution[1],
                grid_mask=None,
                win = grid_target_win, # the method takes a 2d window
                dtype = computation_dtype)
    else:
        # No computation to perform - just select the target window
        # FUTURE_WARNING : if resolution_out != (1,1) we will have to
        # reimplement this part
        # Please note the method takes a window with same ndim as grid
        out[:,:,:] = window_apply(arr=grid, win=grid_target_win3)
    
    return ret